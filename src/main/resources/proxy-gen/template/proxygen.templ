
@declare{'methodBody'}
	@code{lastParam = method.params.get(method.params.size() - 1)}
	@code{hasResultHandler=(lastParam.type.kind == CLASS_HANDLER) && (lastParam.type.args[0].kind == CLASS_ASYNC_RESULT)}
    JsonObject json = new JsonObject();\n
	@code{count=0}
	@foreach{param: method.params}
		@if{count++ != method.params.size() - 1}
    json.putValue("@{param.name}", @{param.name});\n
		@end{}
	@end{}
    DeliveryOptions options = new DeliveryOptions();\n
    options.addHeader("action", "@{method.name}");\n
		@if{hasResultHandler}
    vertx.eventBus().send(address, json, options, res -> {\n
      if (res.failed()) {\n
        @{lastParam.name}.handle(Future.completedFuture(res.cause()));\n
      } else {\n
        @{lastParam.name}.handle(Future.completedFuture(res.result()));\n
      }\n
    });\n
		@else{}
		vertx.eventBus().send(address, json, options);\n
		@end{}

@end{}


@declare{'paramTemplate'}
	@{param.type.simpleName} @{param.name}
@end{}

@declare{'paramArgument'}
	@if{param.type.kind == CLASS_HANDLER}
		@code{eventType=param.type.args[0]}
		@code{eventKind=eventType.kind}
		@if{eventKind.basic || eventKind == CLASS_VOID || eventKind.json}
			@{param.name}
		@else{eventKind == CLASS_LIST || eventKind == CLASS_SET}
			@code{elementType=eventType.args[0]}
			@code{elementKind=elementType.kind}
			@if{elementKind == CLASS_PRIMITIVE || elementKind == CLASS_BOXED_PRIMITIVE || elementKind == CLASS_STRING}
				@{param.name}
			@else{}
				@{param.name}
			@end{}
		@else{eventKind == CLASS_ASYNC_RESULT}
			@code{resultType=eventType.args[0]}
			@code{resultKind=resultType.kind}
			@if{resultKind.basic || resultKind == CLASS_VOID || resultKind.json}
				@{param.name}
			@else{resultKind == CLASS_LIST || resultKind == CLASS_SET}
				@code{elementType=resultType.args[0]}
				@code{elementKind=elementType.kind}
				@if{elementKind == CLASS_PRIMITIVE || elementKind == CLASS_BOXED_PRIMITIVE || elementKind == CLASS_STRING}
					@{param.name}
				@else{}
					@{param.name}
				@end{}
			@else{}
				null /* Handler<AsyncResult<@{resultType.name}>> with kind @{resultKind} not yet implemented */
			@end{}
		@else{}
			null /* Handler<@{eventType.name}> with kind @{eventKind} not yet implemented */
		@end{}
	@else{}
		@{param.name}
	@end{}
@end{}

@declare{'returnTypeTemplate'}
	@{type.simpleName}
@end{}

@declare{'startMethodTemplate'}
public @if{method.staticMethod}static @end{}@if{method.typeParams.size() > 0}<@foreach{typeVar:method.typeParams}@{typeVar}@end{', '}> @end{}@includeNamed{'returnTypeTemplate';type=method.returnType} @{method.name}(@foreach{param: method.params}@includeNamed{'paramTemplate';param=param}@end{', '}) {
@end{}

/*\n
* Copyright 2014 Red Hat, Inc.\n
*\n
* Red Hat licenses this file to you under the Apache License, version 2.0\n
* (the "License"); you may not use this file except in compliance with the\n
* License. You may obtain a copy of the License at:\n
*\n
* http://www.apache.org/licenses/LICENSE-2.0\n
*\n
* Unless required by applicable law or agreed to in writing, software\n
* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n
* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n
* License for the specific language governing permissions and limitations\n
* under the License.\n
*/\n\n
package @{ifacePackageName.replace('io.vertx.ext', 'io.vertx.ext.proxy')};\n
\n
import @{ifaceFQCN};\n
import io.vertx.core.eventbus.DeliveryOptions;\n
import io.vertx.core.Future;\n
@foreach{importedType:importedTypes}
	@if{!importedType.packageName.equals("java.lang")}
		import @{importedType};\n
	@end{}
@end{}
\n
public class @{ifaceSimpleName}Proxy implements @{ifaceSimpleName} {\n
\n
  private Vertx vertx;\n
  private String address;\n
\n
  public @{ifaceSimpleName}Proxy(Vertx vertx, String address) {\n
    this.vertx = vertx;\n
    this.address = address;\n
  }\n
\n
@foreach{method:methods}
	@if{!method.staticMethod}
  @includeNamed{'startMethodTemplate';method:method}\n
		@if{method.fluent}
				@includeNamed{'methodBody';method:method}\n
    return this;\n
		@else{method.returnType.name.equals('void')}
				@includeNamed{'methodBody';method:method}\n
  }\n\n
		@end{}
	@end{}
@end{}

\n
  public void start() {\n
    throw new UnsupportedOperationException("Can't call start() on a service proxy");\n
  }\n
\n
  public void stop() {\n
    throw new UnsupportedOperationException("Can't call stop() on a service proxy");\n
  }\n
\n

}

