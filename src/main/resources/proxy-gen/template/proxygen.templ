
@declare{'methodBody'}
    checkClosed();\n
    JsonObject _json = new JsonObject();\n
	@code{hasParams = !method.params.isEmpty()}
	@code{lastParam = hasParams ? method.params.get(method.params.size() - 1) : null}
	@code{hasResultHandler=(lastParam != null) && (lastParam.type.kind == CLASS_HANDLER) && (lastParam.type.args[0].kind == CLASS_ASYNC_RESULT)}
	@code{count=0}
	@if{method.proxyGenReturn && !method.fluent}
    String addr = java.util.UUID.randomUUID().toString();\n
    @{method.returnType.simpleName} proxy = ProxyHelper.createProxy(@{method.returnType.name}.class, _vertx, addr);\n
	@end{}
	@if{method.proxyClose}
    closed = true;\n
	@end{}
	@foreach{param: method.params}
		@if{!hasResultHandler || (count++ != method.params.size() - 1)}
			@if{param.type.name == 'char' || param.type.name == 'java.lang.Character'}
    _json.put("@{param.name}", (int)@{param.name});\n
			@else{param.type.kind == CLASS_ENUM}
    _json.put("@{param.name}", @{param.name}.toString());\n
			@else{param.type.kind == CLASS_LIST}
    _json.put("@{param.name}", new JsonArray(@{param.name}));\n
			@else{param.type.kind == CLASS_OPTIONS}
    _json.put("@{param.name}", @{param.name}.toJson());\n
			@else{}
    _json.put("@{param.name}", @{param.name});\n
			@end{}
		@end{}
	@end{}

    DeliveryOptions _deliveryOptions = new DeliveryOptions();\n
    _deliveryOptions.addHeader("action", "@{method.name}");\n
	@if{method.proxyGenReturn && !method.fluent}
    _deliveryOptions.addHeader("newproxyaddr", addr);\n
	@end{}
	@if{hasResultHandler}
		@code{resultType=lastParam.type.args[0].args[0]}
		@code{resultKind=resultType.kind}
    _vertx.eventBus().
@if{resultKind == CLASS_LIST}
<JsonArray>
@else{}
<@{resultType.simpleName}>
@end{}
send(_address, _json, _deliveryOptions, res -> {\n
      if (res.failed()) {\n
        @{lastParam.name}.handle(Future.completedFuture(res.cause()));\n
      } else {\n
				@if{resultKind == CLASS_LIST && resultType.args[0].kind == CLASS_JSON_OBJECT}
        @{lastParam.name}.handle(Future.completedFuture(res.result().body().getList()));\n
				@else{resultKind == CLASS_LIST && resultType.args[0].kind == CLASS_JSON_ARRAY}
        @{lastParam.name}.handle(Future.completedFuture(res.result().body().getList()));\n
				@else{resultKind == CLASS_LIST && resultType.args[0].name == 'java.lang.Character'}
        @{lastParam.name}.handle(Future.completedFuture(convertToListChar(res.result().body())));\n
				@else{resultKind == CLASS_LIST}
        @{lastParam.name}.handle(Future.completedFuture(res.result().body().getList()));\n
				@else{}
        @{lastParam.name}.handle(Future.completedFuture(res.result().body()));\n
				@end{}
      }\n
    });\n
	@else{}
    _vertx.eventBus().send(_address, _json, _deliveryOptions);\n
	@end{}

@end{}


@declare{'startMethodTemplate'}
public @if{method.typeParams.size() > 0}
		<@foreach{typeVar:method.typeParams}@{typeVar}@end{', '}>
	 @end{}@{method.returnType.simpleName} @{method.name}(@foreach{param: method.params}@{param.type.simpleName} @{param.name}@end{', '}) {
@end{}

/*\n
* Copyright 2014 Red Hat, Inc.\n
*\n
* Red Hat licenses this file to you under the Apache License, version 2.0\n
* (the "License"); you may not use this file except in compliance with the\n
* License. You may obtain a copy of the License at:\n
*\n
* http://www.apache.org/licenses/LICENSE-2.0\n
*\n
* Unless required by applicable law or agreed to in writing, software\n
* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n
* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n
* License for the specific language governing permissions and limitations\n
* under the License.\n
*/\n\n
package @{ifacePackageName};\n
\n
import @{ifaceFQCN};\n
import io.vertx.core.eventbus.DeliveryOptions;\n
import io.vertx.core.Vertx;\n
import io.vertx.core.Future;\n
import io.vertx.core.json.JsonObject;\n
import io.vertx.core.json.JsonArray;\n
import java.util.List;\n
import java.util.ArrayList;\n
import io.vertx.proxygen.ProxyHelper;\n
@foreach{importedType:importedTypes}
	@if{!importedType.packageName.equals("java.lang")}
		import @{importedType};\n
	@end{}
@end{}
\n
/*\n
  Generated Proxy code - DO NOT EDIT\n
  @author Roger the Robot\n
*/\n
public class @{ifaceSimpleName}VertxEBProxy implements @{ifaceSimpleName} {\n
\n
  private Vertx _vertx;\n
  private String _address;\n
  private boolean closed;\n
\n
  public @{ifaceSimpleName}VertxEBProxy(Vertx vertx, String address) {\n
    this._vertx = vertx;\n
    this._address = address;\n
  }\n
\n
@foreach{method:methods}
	@if{!method.staticMethod}
  @includeNamed{'startMethodTemplate';method:method}\n
		@if{method.fluent}
				@if{!method.proxyIgnore}@includeNamed{'methodBody';method:method}@end{}
    return this;\n
		@else{method.returnType.name.equals('void')}
				@if{!method.proxyIgnore}@includeNamed{'methodBody';method:method}@end{}
		@else{method.proxyGenReturn}
				@if{!method.proxyIgnore}@includeNamed{'methodBody';method:method}@end{}
    return proxy;\n
		@end{}
  }\n\n
	@end{}
@end{}

\n

  private List<Character> convertToListChar(JsonArray arr) {\n
    List<Character> list = new ArrayList<>();\n
    for (Object obj: arr) {\n
      Integer jobj = (Integer)obj;\n
      list.add((char)jobj.intValue());\n
    }\n
    return list;\n
  }\n\n

  private void checkClosed() {\n
    if (closed) {\n
      throw new IllegalStateException("Proxy is closed");\n
    }\n
  }\n

}

