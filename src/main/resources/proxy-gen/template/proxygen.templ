
@declare{'methodBody'}
    JsonObject json = new JsonObject();\n
	@code{hasParams = !method.params.isEmpty()}
	@code{lastParam = hasParams ? method.params.get(method.params.size() - 1) : null}
	@code{hasResultHandler=(lastParam != null) && (lastParam.type.kind == CLASS_HANDLER) && (lastParam.type.args[0].kind == CLASS_ASYNC_RESULT)}
	@code{count=0}
	@foreach{param: method.params}
		@if{!hasResultHandler || (count++ != method.params.size() - 1)}
			@if{param.type.name == 'char' || param.type.name == 'java.lang.Character'}
    json.putValue("@{param.name}", (int)@{param.name});\n
			@else{param.type.kind == CLASS_ENUM}
    json.putValue("@{param.name}", @{param.name}.toString());\n
			@else{param.type.kind == CLASS_LIST}
    json.putValue("@{param.name}", new JsonArray(@{param.name}));\n
			@else{}
    json.putValue("@{param.name}", @{param.name});\n
			@end{}
		@end{}
	@end{}

    DeliveryOptions options = new DeliveryOptions();\n
    options.addHeader("action", "@{method.name}");\n
	@if{hasResultHandler}
		@code{resultType=lastParam.type.args[0].args[0]}
		@code{resultKind=resultType.kind}
    vertx.eventBus().
@if{resultKind == CLASS_LIST}
<JsonArray>
@else{}
<@{resultType.simpleName}>
@end{}
send(address, json, options, res -> {\n
      if (res.failed()) {\n
        @{lastParam.name}.handle(Future.completedFuture(res.cause()));\n
      } else {\n
				@if{resultKind == CLASS_LIST && resultType.args[0].kind == CLASS_JSON_OBJECT}
        @{lastParam.name}.handle(Future.completedFuture(convertToListJsonObject(res.result().body())));\n
				@else{resultKind == CLASS_LIST && resultType.args[0].kind == CLASS_JSON_ARRAY}
        @{lastParam.name}.handle(Future.completedFuture(convertToListJsonArray(res.result().body())));\n
				@else{resultKind == CLASS_LIST && resultType.args[0].name == 'java.lang.Character'}
        @{lastParam.name}.handle(Future.completedFuture(convertToListChar(res.result().body())));\n
				@else{resultKind == CLASS_LIST}
        @{lastParam.name}.handle(Future.completedFuture(res.result().body().toList()));\n
				@else{}
        @{lastParam.name}.handle(Future.completedFuture(res.result().body()));\n
				@end{}
      }\n
    });\n
	@else{}
    vertx.eventBus().send(address, json, options);\n
	@end{}

@end{}


@declare{'startMethodTemplate'}
public @if{method.staticMethod}static @end{}
	@if{method.typeParams.size() > 0}
		<@foreach{typeVar:method.typeParams}@{typeVar}@end{', '}>
	 @end{}@{method.returnType.simpleName} @{method.name}(@foreach{param: method.params}@{param.type.simpleName} @{param.name}@end{', '}) {
@end{}

/*\n
* Copyright 2014 Red Hat, Inc.\n
*\n
* Red Hat licenses this file to you under the Apache License, version 2.0\n
* (the "License"); you may not use this file except in compliance with the\n
* License. You may obtain a copy of the License at:\n
*\n
* http://www.apache.org/licenses/LICENSE-2.0\n
*\n
* Unless required by applicable law or agreed to in writing, software\n
* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n
* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n
* License for the specific language governing permissions and limitations\n
* under the License.\n
*/\n\n
package @{ifacePackageName.replace('io.vertx.ext', 'io.vertx.ext.proxy')};\n
\n
import @{ifaceFQCN};\n
import io.vertx.core.eventbus.DeliveryOptions;\n
import io.vertx.core.Future;\n
import java.util.ArrayList;
@foreach{importedType:importedTypes}
	@if{!importedType.packageName.equals("java.lang")}
		import @{importedType};\n
	@end{}
@end{}
\n
/*\n
  Generated Proxy code - DO NOT EDIT\n
*/\n
public class @{ifaceSimpleName}VertxEBProxy implements @{ifaceSimpleName} {\n
\n
  private Vertx vertx;\n
  private String address;\n
\n
  public @{ifaceSimpleName}VertxEBProxy(Vertx vertx, String address) {\n
    this.vertx = vertx;\n
    this.address = address;\n
  }\n
\n
@foreach{method:methods}
	@if{!method.staticMethod}
  @includeNamed{'startMethodTemplate';method:method}\n
		@if{method.fluent}
				@includeNamed{'methodBody';method:method}
    return this;\n
		@else{method.returnType.name.equals('void')}
				@includeNamed{'methodBody';method:method}
		@end{}
  }\n\n
	@end{}
@end{}

\n
  public void start() {\n
    throw new UnsupportedOperationException("Can't call start() on a service proxy");\n
  }\n
\n
  public void stop() {\n
    throw new UnsupportedOperationException("Can't call stop() on a service proxy");\n
  }\n
\n
  // This is clunky, but will disappear once we refactor JsonObject to be a map\n
  private List<JsonObject> convertToListJsonObject(JsonArray arr) {\n
    List<JsonObject> list = new ArrayList<>();\n
    for (Object obj: arr) {\n
      JsonObject jobj = (JsonObject)obj;\n
      list.add(jobj);\n
    }\n
    return list;\n
  }\n

  // This is clunky, but will disappear once we refactor Json stuff\n
  private List<JsonArray> convertToListJsonArray(JsonArray arr) {\n
    List<JsonArray> list = new ArrayList<>();\n
    for (Object obj: arr) {\n
      JsonArray jobj = (JsonArray)obj;\n
      list.add(jobj);\n
    }\n
    return list;\n
  }\n

  private List<Character> convertToListChar(JsonArray arr) {\n
    List<Character> list = new ArrayList<>();\n
    for (Object obj: arr) {\n
      Integer jobj = (Integer)obj;\n
      list.add((char)jobj.intValue());\n
    }\n
    return list;\n
  }\n

}

