/*\n
* Copyright 2014 Red Hat, Inc.\n
*\n
* Red Hat licenses this file to you under the Apache License, version 2.0\n
* (the "License"); you may not use this file except in compliance with the\n
* License. You may obtain a copy of the License at:\n
*\n
* http://www.apache.org/licenses/LICENSE-2.0\n
*\n
* Unless required by applicable law or agreed to in writing, software\n
* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n
* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n
* License for the specific language governing permissions and limitations\n
* under the License.\n
*/\n\n
package @{ifacePackageName};\n
\n
import @{ifaceFQCN};\n
import io.vertx.core.Handler;\n
import io.vertx.core.eventbus.Message;\n
import io.vertx.core.eventbus.ReplyException;\n
import io.vertx.core.json.JsonObject;\n
import io.vertx.core.json.JsonArray;\n
@foreach{importedType:importedTypes}
	@if{!importedType.packageName.equals("java.lang")}
		import @{importedType};\n
	@end{}
@end{}
\n
/*\n
  Generated Proxy code - DO NOT EDIT\n
  @author Roger the Robot\n
*/\n
public class @{ifaceSimpleName}VertxProxyHandler implements Handler<Message<JsonObject>> {\n
\n
  private Vertx vertx;\n
  private @{ifaceSimpleName} service;\n
\n
  public @{ifaceSimpleName}VertxProxyHandler(Vertx vertx, @{ifaceSimpleName} service) {\n
    this.vertx = vertx;\n
    this.service = service;\n
  }\n
\n
  public void handle(Message<JsonObject> msg) {\n
    JsonObject json = msg.body();\n
    String action = msg.headers().get("action");\n
    if (action == null) {\n
      throw new IllegalStateException("action not specified");\n
    }\n
    switch (action) {\n
@foreach{method:methods}
	@if{!method.staticMethod}
      case "@{method.name}": {\n
        service.@{method.name}(
		@code{hasParams = !method.params.isEmpty()}
		@code{lastParam = hasParams? method.params.get(method.params.size() - 1) : null}
		@code{hasResultHandler=(lastParam != null) && (lastParam.type.kind == CLASS_HANDLER) && (lastParam.type.args[0].kind==CLASS_ASYNC_RESULT)}
		@code{count=0}
		@foreach{param: method.params}
			@if{!hasResultHandler || (count++ != method.params.size() - 1)}
				@if{param.type.name == 'char' || param.type.name == 'java.lang.Character'}
(char)(json.getInteger("@{param.name}").intValue())
				@else{param.type.kind == CLASS_ENUM}
@{param.type.name}.valueOf(json.getString("@{param.name}"))
				@else{param.type.kind == CLASS_LIST}
json.getJsonArray("@{param.name}").toList()
				@else{param.type.kind == CLASS_OPTIONS}
new @{param.type.name}(json.getJsonObject("@{param.name}"))
				@else{}
(@{param.type.name})json.getValue("@{param.name}")
				@end{}
			@else{hasResultHandler && lastParam.type.args[0].args[0].kind==CLASS_LIST && lastParam.type.args[0].args[0].args[0].kind==CLASS_JSON_OBJECT}
createListJsonObjectHandler(msg)
			@else{hasResultHandler && lastParam.type.args[0].args[0].kind==CLASS_LIST && lastParam.type.args[0].args[0].args[0].kind==CLASS_JSON_ARRAY}
createListJsonArrayHandler(msg)
			@else{hasResultHandler && lastParam.type.args[0].args[0].kind==CLASS_LIST && lastParam.type.args[0].args[0].args[0].name=='java.lang.Character'}
createListCharHandler(msg)
			@else{hasResultHandler && lastParam.type.args[0].args[0].kind==CLASS_LIST}
createListHandler(msg)
			@else{}
createHandler(msg)
			@end{}
		@end{", "});\n
        break;\n
      }
	@end{}
\n
@end{}
      default: {\n
        throw new IllegalStateException("Invalid action: " + action);\n
      }\n
    }\n

  }\n

  private <T> Handler<AsyncResult<T>> createHandler(Message msg) {\n
    return res -> {\n
      if (res.failed()) {\n
        msg.fail(-1, res.cause().getMessage());\n
      } else {\n
        msg.reply(res.result());\n
      }\n
    };\n
  }\n

  private <T> Handler<AsyncResult<List<T>>> createListHandler(Message msg) {\n
    return res -> {\n
      if (res.failed()) {\n
        msg.fail(-1, res.cause().getMessage());\n
      } else {\n
        msg.reply(new JsonArray(res.result()));\n
      }\n
    };\n
  }\n

  // This is clunky, but will disappear once we refactor JsonObject to be a map\n
  private Handler<AsyncResult<List<JsonObject>>> createListJsonObjectHandler(Message msg) {\n
    return res -> {\n
      if (res.failed()) {\n
        msg.fail(-1, res.cause().getMessage());\n
      } else {\n
        JsonArray arr = new JsonArray();\n
        for (JsonObject obj: res.result()) {\n
          arr.add(obj);\n
        }\n
        msg.reply(arr);\n
      }\n
    };\n
  }\n

  // This is clunky, but will disappear once we refactor JsonArray to be a list\n
  private Handler<AsyncResult<List<JsonArray>>> createListJsonArrayHandler(Message msg) {\n
    return res -> {\n
      if (res.failed()) {\n
        msg.fail(-1, res.cause().getMessage());\n
      } else {\n
        JsonArray arr = new JsonArray();\n
        for (JsonArray obj: res.result()) {\n
          arr.add(obj);\n
        }\n
        msg.reply(arr);\n
      }\n
    };\n
  }\n

  private Handler<AsyncResult<List<Character>>> createListCharHandler(Message msg) {\n
    return res -> {\n
      if (res.failed()) {\n
        msg.fail(-1, res.cause().getMessage());\n
      } else {\n
        JsonArray arr = new JsonArray();\n
        for (Character chr: res.result()) {\n
          arr.add((int)chr);\n
        }\n
        msg.reply(arr);\n
      }\n
    };\n
  }\n
}

